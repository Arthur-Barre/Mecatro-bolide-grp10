/*Etat du script :
/Connexion multiplexeur : OK
/Connexion 2 Encodeurs : OK
/Connexion 2 Moteurs : OK
/Connexion Wifi : OUI
/Connexion SensorBar : OK
/MODE HYBRIDE : Reçoit gains de MATLAB ou utilise valeurs par défaut
*/

#include "MecatroUtils.h"

// Include the SensorBar library (for Line Follower) 
#include "sensorbar.h"
// Include the AS5600 library (for the encoders) 
#include "AS5600.h"
// Include Sparkfun I2C Mux (for multiplexer)
#include "SparkFun_I2C_Mux_Arduino_Library.h"
QWIICMUX multiplexer;
AS5600 rightEncoder(&Wire1);
AS5600 leftEncoder(&Wire1);

// Header for I2C communication
#include "Wire.h"

// Define the name and password of the wifi network
#define WIFI_SSID "Group10"
#define WIFI_PASSWRD "password1234"

// Define the control loop period, in ms.
#define CONTROL_LOOP_PERIOD 3
#define TAU 100.0e-3

// Définition des Pins
SensorBar mySensorBar(0x3E);
#define SENSORBAR_PIN 4
#define RIGHT_ENCODER_PIN 7
#define LEFT_ENCODER_PIN 0

#define PI 3.1415926
#define DEG_TO_RAD 2*PI/360

// ===== GAINS DU CONTROLEUR - Valeurs par défaut =====
// Ces valeurs seront écrasées si MATLAB envoie des gains
float Kp = 12.0;        // Gain proportionnel vitesse
float Ki = 6.0;         // Gain intégral vitesse
float K_moins = 24.0;   // Gain proportionnel direction
float K_lambda = 7.0;   // Gain intégral direction
float Vbatt = 11.2;     // Tension batterie
float u_barre = 0.3;    // Vitesse cible en m/s

// Définition des variables utiles
float PosSensorBar = 0.0;
float CumulativePosRight_0 = 0.0;
float CumulativePosLeft_0 = 0.0;

float speed=0.0;
float delta=0.0;
float compteur=0;

float lambda = 0.0;

float RawAngle[2]={0.0,0.0};
float RawAngle_new[2]={0.0,0.0};

float OmegaD = 0.0;
float OmegaG = 0.0;
float OmegaD_prev = 0.0;
float OmegaG_prev = 0.0;

// Coeff du filtre dérivateur
float a1 =-(1 - 2*TAU / (CONTROL_LOOP_PERIOD*0.001));
float b1 = (1 + 2*TAU / (CONTROL_LOOP_PERIOD*0.001));

// Paramètres du système
float p = 0.04;           // rayon des roues, en m
float U_plus_barre = 4.0; // Tension d'équilibre (sera calculée)

// Variables d'état du controleur
float dt = CONTROL_LOOP_PERIOD*0.001;
float eta_u = 0.0;
float eta_lambda = 0.0;
float u = 0.0;

// Les Tensions utiles
float U;
float U_plus = 0.0;
float U_moins = 0.0;


void Controleur(float lambda, float OmegaD, float OmegaG, float *U_plus, float *U_moins, float *u) {
  // Calcul de U_moins via PI (contrôle direction)
  eta_lambda += lambda*dt;
  float dU_moins = -K_moins * lambda - K_lambda*eta_lambda;
  *U_moins = dU_moins;
  *U_moins = constrain(*U_moins, -12.0, 12.0);

  // Calcul de U_plus via PI (contrôle vitesse)
  *u = p * (OmegaD + OmegaG) / 2.0;
  float du = u_barre - *u;
  eta_u += du * dt;
  float dU_plus = -Ki * eta_u - Kp * du;
  *U_plus = U_plus_barre + dU_plus;
  *U_plus = constrain(*U_plus, -12.0, 12.0);
}

void setup() {
  Serial.begin(230400);
  Wire1.begin();

  Serial.println("=== ROBOT SUIVEUR DE LIGNE ===");
  Serial.println("Mode hybride - peut recevoir gains de MATLAB");

  if (!multiplexer.begin(0x70,Wire1)){
    Serial.println("ERREUR: multiplexeur non fonctionnel");
    while(1); // Bloque si erreur critique
  }
  else {
    Serial.println("Multiplexeur OK");
    bool isInit = true;

    // Configuration SensorBar
    mySensorBar.clearBarStrobe();
    mySensorBar.clearInvertBits(); // Ligne NOIRE sur fond BLANC
    // Si ligne blanche sur fond noir, décommentez la ligne suivante :
    // mySensorBar.setInvertBits();
    
    multiplexer.setPort(SENSORBAR_PIN);
    uint8_t returnStatus = mySensorBar.begin();

    if(!returnStatus)
    {
      Serial.println("ERREUR: SensorBar non fonctionnelle");
      isInit = false;
    }
    else {
      Serial.println("SensorBar OK");
    }
  
    // Init encodeur droit
    multiplexer.setPort(RIGHT_ENCODER_PIN);
    rightEncoder.begin();
    if (!rightEncoder.isConnected())
    {
      Serial.println("ERREUR: encodeur droit non connecté");
      isInit = false;
    }
    else {
      Serial.println("Encodeur droit OK");
    }
 
    // Init encodeur gauche
    multiplexer.setPort(LEFT_ENCODER_PIN);
    leftEncoder.begin();
    if (!leftEncoder.isConnected())
    {
      Serial.println("ERREUR: encodeur gauche non connecté");
      isInit = false;
    }
    else {
      Serial.println("Encodeur gauche OK");
    }

    // Initialisation positions
    multiplexer.setPort(RIGHT_ENCODER_PIN);
    RawAngle[0] = rightEncoder.getCumulativePosition() * AS5600_RAW_TO_DEGREES;
    CumulativePosRight_0 = RawAngle[0];
    
    multiplexer.setPort(LEFT_ENCODER_PIN);
    RawAngle[1] = leftEncoder.getCumulativePosition() * AS5600_RAW_TO_DEGREES;
    CumulativePosLeft_0 = RawAngle[1];

    OmegaD_prev = 0;
    OmegaG_prev = 0;

    if (isInit)
    {
      Serial.println("=== INITIALISATION REUSSIE ===");
      
      // Test SensorBar
      Serial.println("\nTest SensorBar (3 secondes):");
      Serial.println("Placez le robot sur la ligne");
      multiplexer.setPort(SENSORBAR_PIN);
      for(int i=0; i<30; i++) {
        int pos = mySensorBar.getPosition();
        uint8_t density = mySensorBar.getDensity();
        Serial.print("Pos: "); 
        Serial.print(pos);
        Serial.print(" | Dens: "); 
        Serial.println(density);
        delay(100);
      }
      
      // Initialisation télémétrie
      unsigned int const nVariables = 10;
      String variableNames[nVariables] = {"angleDroite","angleGauche","Omega Droite","Omega Gauche","SensorBar","lambda","U","u","U_plus","U_moins"};
      mecatro::initTelemetry(WIFI_SSID, WIFI_PASSWRD, nVariables, variableNames, CONTROL_LOOP_PERIOD);

      Serial.println("\n=== ATTENTE GAINS MATLAB ===");
      Serial.println("Le robot attend les gains de MATLAB...");
      Serial.println("Si MATLAB n'envoie rien, le robot utilisera les gains par defaut.");
      
      // RECEPTION DES GAINS depuis MATLAB
      float floatArray[6]; // 6 valeurs maintenant : K_moins, Kp, Ki, K_lambda, Vbatt, u_barre
      mecatro::recieveGains(6, floatArray);
      
      // Mise à jour des gains
      K_moins = floatArray[0];
      Kp = floatArray[1];
      Ki = floatArray[2];
      K_lambda = floatArray[3];
      Vbatt = floatArray[4];
      u_barre = floatArray[5];
      
      // Calcul automatique de U_plus_barre basé sur u_barre
      // Formule empirique : U_plus_barre ≈ 12 * u_barre (à ajuster selon votre robot)
      U_plus_barre = 12.0 * u_barre;
      if (U_plus_barre > 10.0) U_plus_barre = 10.0; // Limité à 10V
      if (U_plus_barre < 2.0) U_plus_barre = 2.0;   // Minimum 2V
      
      Serial.println("\n=== PARAMETRES RECUS ===");
      Serial.print("  K_moins = "); Serial.println(K_moins);
      Serial.print("  K_lambda = "); Serial.println(K_lambda);
      Serial.print("  Kp = "); Serial.println(Kp);
      Serial.print("  Ki = "); Serial.println(Ki);
      Serial.print("  Vbatt = "); Serial.print(Vbatt); Serial.println(" V");
      Serial.print("  u_barre = "); Serial.print(u_barre); Serial.println(" m/s");
      Serial.print("  U_plus_barre (calcule) = "); Serial.print(U_plus_barre); Serial.println(" V");
      
      Wire1.setClock(400000);
      mecatro::configureArduino(CONTROL_LOOP_PERIOD);
      
      Serial.println("\n=== ROBOT EN MARCHE ===");
    }
    else {
      Serial.println("ERREUR: Initialisation echouee");
      while(1); // Bloque si erreur
    }
  }
}

void loop() {
  mecatro::run();
}

void mecatro::controlLoop()
{
  // Lecture SensorBar
  multiplexer.setPort(SENSORBAR_PIN);
  PosSensorBar = mySensorBar.getPosition()*0.0458/127;
  lambda = -PosSensorBar;  // NEGATIF pour inverser le sens

  // Encodeur droit
  multiplexer.setPort(RIGHT_ENCODER_PIN);
  RawAngle_new[0] = rightEncoder.getCumulativePosition() * AS5600_RAW_TO_DEGREES;

  // Encodeur gauche
  multiplexer.setPort(LEFT_ENCODER_PIN);
  RawAngle_new[1] = leftEncoder.getCumulativePosition() * AS5600_RAW_TO_DEGREES;
 
  // Calcul vitesses filtrées
  OmegaD = (2.0/(CONTROL_LOOP_PERIOD*0.001)*(RawAngle_new[0]-RawAngle[0])*DEG_TO_RAD + a1 * OmegaD_prev)/b1;
  OmegaG = (2.0/(CONTROL_LOOP_PERIOD*0.001)*(RawAngle_new[1]-RawAngle[1])*DEG_TO_RAD + a1 * OmegaG_prev)/b1;

  // Appel au controleur
  Controleur(lambda, OmegaD, OmegaG, &U_plus, &U_moins, &u);
  
  // Calcul duty cycles
  float delta_d = (U_plus + U_moins)/Vbatt;
  float delta_g = (U_plus - U_moins)/Vbatt;

  // Commande moteurs
  mecatro::setMotorDutyCycle(delta_g, delta_d);

  // Télémétrie
  mecatro::log(0, RawAngle[0]-CumulativePosRight_0);
  mecatro::log(1, RawAngle[1]-CumulativePosLeft_0);
  mecatro::log(2, OmegaD);
  mecatro::log(3, OmegaG);
  mecatro::log(4, PosSensorBar); 
  mecatro::log(5, lambda);
  mecatro::log(6, U);
  mecatro::log(7, u);
  mecatro::log(8, U_plus);
  mecatro::log(9, U_moins);
  
  // Mise à jour valeurs précédentes
  for (int i = 0; i < 2; i++) {
    RawAngle[i] = RawAngle_new[i];
  }
  OmegaG_prev = OmegaG;
  OmegaD_prev = OmegaD;
}